924. Minimize Malware Spread
===============================
// You are given a network of n nodes represented as an n x n adjacency 
// matrix graph, where the ith node is directly connected to the jth node if 
// graph[i][j] == 1.

// Some nodes initial are initially infected by malware. Whenever two nodes 
// are directly connected, and at least one of those two nodes is infected by 
// malware, both nodes will be infected by malware. This spread of malware will 
// continue until no more nodes can be infected in this manner.

// Suppose M(initial) is the final number of nodes infected with malware in the 
// entire network after the spread of malware stops. We will remove exactly one 
// node from initial.

// Return the node that, if removed, would minimize M(initial). If multiple nodes 
// could be removed to minimize M(initial), return such a node with the smallest index.

// Note that if a node was removed from the initial list of infected nodes, 
// it might still be infected later due to the malware spread.

 

// Example 1:

// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// Output: 0

// Example 2:

// Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
// Output: 0

// Example 3:

// Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
// Output: 1


// Union found all nodes.
// Count the union size of each union set.
// Count the malware number of each union set.

// Return the biggest union''s malware if there is one and only one malware.
// If no such union that has and has only one malware,
// return the malware with minimum index.

// Time Complexity: O(N^2)



    vector<int> parents;
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        for (int i = 0; i < n; ++i) parents.push_back(i);
        for (int i = 0; i < n; ++i)
            for (int j = i + 1; j < n; ++j)
                if (graph[i][j]) uni(i, j);
        vector<int> area(n, 0), malware(n, 0);
        for (int i = 0; i < n; ++i) area[find(i)]++;
        for (int i : initial) malware[find(i)]++;
        vector<int> res = {1, 0};
        for (int i : initial)
            res = min(res, {(malware[find(i)] == 1 ) * (-area[find(i)]), i});
        return res[1];
    }

    int find(int x) {
        if (x != parents[x])
            parents[x] = find(parents[x]);
        return parents[x];
    }
    void uni(int x, int y) {
        parents[find(x)] = find(y);
    }



    def minMalwareSpread(self, graph, initial):
        def find(x):
            if x != parents[x]:
                parents[x] = find(parents[x])
            return parents[x]
        def union(x, y):
            parents[find(x)] = find(y)
        # init
        n = len(graph)
        parents = range(n)
        # union
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    union(i, j)
        area = collections.Counter(find(i) for i in range(n))
        malware = collections.Counter(find(i) for i in initial)
        return min(initial, key=lambda i: [(malware[find(i)] == 1) * -area[find(i)], i])

The last line equals to :

        save, res = 0, min(initial)
        for i in initial:
            if malware[find(i)] == 1:
                if area[find(i)] > save:
                    save, res = area[find(i)], i
                elif area[find(i)] == save:
                    res = min(res, i)
        return res
